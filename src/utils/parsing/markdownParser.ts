import { unified } from 'unified';
import remarkParse from 'remark-parse';
import { visit, SKIP } from 'unist-util-visit';
import { toString as nodeToString } from 'mdast-util-to-string';
import { Root, Content, List, ListItem, Code, Paragraph, Heading, Blockquote, ThematicBreak, Parent, Node as UnistNode } from 'mdast';
import { ISentence } from '@/utils/mongodb/models';
import { MarkdownType, ISentenceMetadata } from '@/utils/mongodb/schemas/sentence.schema';

// Type definition for the output sentences, excluding fields generated by MongoDB or linking logic
export type ParsedSentence = Omit<ISentence, '_id' | 'psid' | 'nsid'>;

/**
 * Parses a Markdown string into an array of Sentence objects using AST traversal.
 * Assigns sequential sids starting from 0 (linking is handled separately).
 * Tries to capture indentation for list items.
 * @param markdown The Markdown content to parse.
 * @param conceptCid The concept ID to associate with the sentences.
 * @returns An array of ParsedSentence objects.
 */
export function parseMarkdownToSentences(markdown: string, conceptCid: string): ParsedSentence[] {
  const processor = unified().use(remarkParse);
  const tree = processor.parse(markdown) as Root;
  const sentences: ParsedSentence[] = [];
  let currentSid = 0;
  const publishedAt = new Date();

  console.log("--- Starting Markdown Parse (v15) ---");

  const listStack: Array<{ node: List, currentItemIndex: number }> = [];

  visit(tree, (node: UnistNode, index?: number | null, parent?: Parent | null) => {
    const parentType = parent?.type ?? 'root';
    const nodeLogPrefix = `[${parentType}>${node.type}]`;

    // --- Stack Management ---
    if (node.type === 'listItem') {
      // Before processing this listItem, ensure stack is correct relative to its parent list.
      // Pop contexts until the stack top matches the parent list or stack is empty.
      while (listStack.length > 0 && parent !== listStack[listStack.length - 1].node) {
        const popped = listStack.pop();
        console.log(`${nodeLogPrefix} Popped parent list context (Ordered: ${popped?.node.ordered}) before processing item. Stack depth: ${listStack.length}`);
        if (!parent) break; // Should not happen if node is listItem, but safety check
      }

      // Now increment index for the list context *currently* on top (if any)
      if (listStack.length > 0) {
        // Ensure the parent IS the list on the stack top (should be after the while loop)
        if (parent === listStack[listStack.length - 1].node) {
          listStack[listStack.length - 1].currentItemIndex++;
          console.log(`${nodeLogPrefix} Incremented item index for list. Current index: ${listStack[listStack.length - 1]?.currentItemIndex ?? 'N/A'}`);
        } else {
          console.warn(`${nodeLogPrefix} Parent mismatch after stack correction.`);
        }
      } else {
        console.warn(`${nodeLogPrefix} listItem encountered without parent list context in stack.`);
      }
      return; // Continue descent into listItem children (paragraph etc.)
    }

    if (node.type === 'list') {
      // Entering a new list, push its context.
      listStack.push({ node: node as List, currentItemIndex: 0 });
      const list = node as List;
      console.log(`${nodeLogPrefix} Pushed list context. Ordered: ${list.ordered}, Start: ${list.start}. Stack depth: ${listStack.length}`);
      return; // Continue descent
    }

    // --- Process Content Nodes ---
    let sentenceType: MarkdownType | null = null;
    let content = '';
    let metadata: ISentenceMetadata = {};
    let addSentence = false;
    let skipChildren = false;

    switch (node.type) {
      case 'heading':
        const headingNode = node as Heading;
        sentenceType = MarkdownType[headingNode.depth === 1 ? 'Heading1' : headingNode.depth === 2 ? 'Heading2' : headingNode.depth === 3 ? 'Heading3' : headingNode.depth === 4 ? 'Heading4' : headingNode.depth === 5 ? 'Heading5' : 'Heading6'];
        content = nodeToString(headingNode).trim();
        addSentence = !!content;
        skipChildren = true;
        break;
      case 'paragraph':
        const paragraphNode = node as Paragraph;
        content = nodeToString(paragraphNode).trim();
        if (content) {
          // Check if the direct parent is a listItem AND if we are inside a list context
          if (parent?.type === 'listItem' && listStack.length > 0) {
            const listItemNode = parent as ListItem; // Parent is confirmed listItem
            const currentListContext = listStack[listStack.length - 1];

            // Double check: does the list context match the list containing this item?
            // This assumes the stack IS correct due to the logic in 'listItem' visitor part.
            const parentList = currentListContext.node;
            const parentListItemIndex = currentListContext.currentItemIndex;
            const indentation = listItemNode?.position?.start?.column ? listItemNode.position.start.column - 1 : 0;

            sentenceType = MarkdownType.ListItem;
            metadata.indentation = indentation;
            metadata.ordered = parentList.ordered ?? false;

            if (metadata.ordered) {
              metadata.start = parentList.start ?? 1;
              metadata.itemNumber = (metadata.start || 1) + parentListItemIndex - 1;
              console.log(`${nodeLogPrefix} Setting type: ListItem. Indent: ${indentation}. Ordered: ${metadata.ordered}, Item #: ${metadata.itemNumber}`);
            } else {
              console.log(`${nodeLogPrefix} Setting type: ListItem. Indent: ${indentation}. Ordered: false`);
            }
          } else {
            // Top-level paragraph or paragraph not directly in a list item
            sentenceType = MarkdownType.Paragraph;
            console.log(`${nodeLogPrefix} Setting type: Paragraph.`);
          }
          addSentence = true;
        } else {
          console.log(`${nodeLogPrefix} Skipping empty paragraph.`);
          addSentence = false;
        }
        skipChildren = true; // Don't visit text nodes inside paragraph
        break;
      case 'code':
        const codeNode = node as Code;
        sentenceType = MarkdownType.Code;
        content = codeNode.value;
        metadata.lang = codeNode.lang ?? undefined;
        metadata.meta = codeNode.meta ?? undefined;
        addSentence = true;
        skipChildren = true;
        break;
      case 'blockquote':
        const blockquoteNode = node as Blockquote;
        sentenceType = MarkdownType.Blockquote;
        content = nodeToString(blockquoteNode).trim();
        addSentence = !!content;
        skipChildren = true;
        break;
      case 'thematicBreak':
        sentenceType = MarkdownType.HorizontalRule;
        content = '---';
        addSentence = true;
        skipChildren = true;
        break;
      default:
        // console.log(`${nodeLogPrefix} Node type not processed for sentence creation. Type: ${node.type}`);
        break;
    }

    // --- Add Sentence to Array ---
    if (addSentence && sentenceType) {
      console.log(`--> Adding Sentence: Type=${sentenceType}, SID=${currentSid}, Content: "${content.replace(/\n/g, '\\n').substring(0, 50)}..."`, metadata);
      sentences.push({
        sid: currentSid++,
        cid: conceptCid,
        content: content,
        type: sentenceType,
        publishedAt: publishedAt,
        metadata: metadata,
      });
      if (skipChildren) {
        console.log(`${nodeLogPrefix} Added sentence, skipping children.`);
        return SKIP;
      }
    }
    // If no sentence was added, or if we shouldn't skip children (e.g. for list/listItem),
    // continue traversal implicitly by returning void/nothing.
  });

  console.log(`--- Parser finished. Total sentences generated: ${sentences.length} ---`);
  return sentences;
} 